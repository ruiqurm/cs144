# LAB1
这个lab因为种种原因，耽搁了几个月才把它完成。由于没有认真看题目（或者说有些地方没看懂），也碰上了很多坑。

## 题目
题目的大意是要实现一个能够自动组装分片的`reassembler`，并且还要把结果用`ByteStream`导出来。

需要注意的地方至少有以下几个：
* `stream_out`导出是任何时候都可以的，意味着你不能等到eof接到后，再把字符串放进stream_out。
* 要好好理解这张图：
![](https://i.loli.net/2021/07/08/MjGpQOl7xyrkiSA.png)
    * `stream_start`是什么？是我们接到的index=0的字节
    * `first_unread`是什么？是`stream_out`的读取状态。每当`stream_out`被读出的时候，都会使得状态发生变化。当时由于时间久远，我都忘了`stream_out`里还有`unread`这个属性了。
    * `capacity`是什么？注意是从**first_unread**开始算的，而不是`first_unassembled`。因此每次计算`unacceptable`的时候，要读取`stream_out`的状态。
    * `first_unassembled`什么时候变化？只有接到第一片包含`first_unassembled`的数据段的时候才会变化。注意这个时候**first_unread没有变**。
    * `eof`表示的是本段中最后一个字节是结束字节，而不是表示本段是最后一段。因此要做好判断和记录，如果eof字节恰好在缓冲区之外，就不能置eof，但是要缓存eof的偏置序号。

    以上几个问题都是要好好明确一下的。
## 具体的实现

代码位于`libsponge`下，这里就不贴出来了。

这个lab最大的代码量主要在做区间合并上。相关的算法有很多，可以自行搜索学习。这里我用一个capacity长度的数组来保存数据，使用取模把数据映射到数组上。网上常见的做法是写一个`segement`的类，这个类负责管理区间和字符串，给类加上合并区间的操作。这样的写法在逻辑上很清晰，效率也很高。我因为前期理解错了，把这里当成滑动窗口来做，事实上区间合并的时候，窗口是不会变化的。后面修改的时候就不再动底层了。

在判断区间合并上，算法是这样的：
1. 假设新区间是`[left,right)`。
2. 在原有区间中，按左区间为索引，找到比`left'`当前`left`大的最小元素。
3. 假设要插入的位置是`[left1,right1),[left,right),[left2,right2)`，不失一般性，不如假设前面一定有元素（没有的话第4步就不用做了）。
4. 如果`left`比`right1`小，`new_left`=`min(left,lef1)`
5. 向右删除旧区间，直到`right`小于等于`lefti`