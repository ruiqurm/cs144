# 准备
这个lab一开始有点难以下手，几个成员变量类都是之前没用过的。  
先看看初始模板都给了什么。   
### _segments_out
这是Sender内部维护一个队列。我们需要把发的东西放进队列里面。需要注意的是，和STL的队列不同，这里的队列要先push，然后取它的引用来赋值（而不是先构造一个对象再push).
### TCPHeader
header对象就是TCP的头部报文。这里我们主要要修改的是各种FLAG和Seq。对于校验和，端口之类的不需要管。使用的时候，这样写就可以:
```cpp
segment s;
s.header().syn = true;
```

### TCPpayload
这个Payload我一开始以为要用parse才能赋值，后来测试的时候发现赋不上值。后面搜了sponge内部使用TCPSegment的代码发现，它是直接赋值的，因为这里重载了`string_view`
```cpp
TCPSegment seg;
seg.payload() = std::string(data); // data也是string类型
```
注意右边必须要是一个右值引用（将亡值），如果直接写data会报错。
关于string_view，我也不太了解，后面补上
### _stream
这是输入的流。注意它不是一直有值的，也可能是慢慢的输入的。当输入结束，产生EOF的时候，可以通过_stream.eof()判断（不要用_stream.empty()去判断结束）
### 其他
还有很多细节，这些细节放在下面的实现中细说。
# 超时重传器
这里把超时重传器单独分开了一个类`TCPRetransmissionTimer`。超时重传器主要负责
* 累加tick
* 判断是否超时
* 翻倍RTO和RTO复原
* 重置定时器  
* 保存重传时需要的数据（比如seq,payload,syn和fin的标记）   
等。这些的实现都很简单，可以参见[tcp_retransmission_timer.hh](../libsponge/tcp_retransmission_timer.hh)，这里不再赘述。后面遇到特殊情况会再说。   
## 维护多个片段的定时器
对于每一个tcp窗口，都要有一个定时器。每一次ACK，都需要清理掉那些被确认的定时器。一开始我是用map去维护的，因为之前接收方窗口也是类似的维护方法。但写到后面发现并不需要这样。因为发送数据流是顺序的，而每次删除也是顺序的。如果用map反而需要维护下一个片段是什么。因此后面改为链表。
## 当发送时...
发送数据时，定时器的操作比较简单。只需要向链表中添加一个定时器，保存数据包，启动定时器即可。
## 当接收时...
* 每次接收到数据包，都应该更新窗口大小（即使ACK没有新的确认）
* 如果这个ACK是**超前**或者冗余的，都要去掉
* 删除掉已经ACK的定时器
	* 顺序遍历链表，如果ACK seq大于当前块的区间（指[seq,seq+size),这里size包括FIN或SYN），那么break掉
	* 如果这个ACK是有效的（非超前或者冗余的）
		* 删除定时器
		* 减少_bytes_in_flight
	* 如果存在有效的ACK
		* 超时重传次数清0
		* 剩余的定时器计时清0
		* 计时器的RTO变为初始RTO
## 当增加tick时...
* 顺序遍历并给定时器添加tick
* 出现超时时，进行一次重传（只重传一个）
* 对于其他的定时器（即除了重传的那个），时间重新置为0
（我一开始写的是发生超时重传后，后面的定时器清0，前面的定时器就没清0了，但是这样也过了..)
* 对于超时重传，要加倍RTO，重启定时器。
# fill_window
fill_window因为一直出bug，改的比较复杂，以后有空可以合并一下多余的条件。   
这里我把syn和非syn的分开了。   
下面只说非syn的情况。
## fill的条件  
首先fill_window函数不仅是发送的时候会被调用，每次ack_received的时候也会被调用（`piggy_backing`).  
因此：
* `_stream`没有结束，且`_stream`是空的
* `_stream`已经结束，且`FIN`flag发出去了
* 当前没有足够的窗口来发送数据（注意窗口包括SYN和FIN）    
这三种情况就不需要发了。
## 窗口
* 窗口要扣掉之前发送的数据(`bytes_in_flight`)占的位置
* SYN,FIN占一个位置
## 分片
如果要填充的窗口很大，大于了1452，那就要进行分片。    
* 注意FIN不占分片的位置。也就是说，如果有一个数据长度是1452带FIN，那它就不用再分片

